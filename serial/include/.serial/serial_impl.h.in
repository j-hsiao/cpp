#include <serial/serial_dllcfg.h>

#include <string.h>
#include <limits.h>

#define SERIAL_LITTLE_ENDIAN 1
#define SERIAL_BIG_ENDIAN 2
#define SERIAL_UNKNOWN_ENDIAN 3

#define SERIAL_TWO_REP 1
#define SERIAL_ONE_REP 2
#define SERIAL_SMAG_REP 3
#define SERIAL_UNKNOWN_REP 4

#define SERIAL_ENDIAN SERIAL_@SERIAL_ENDIAN@_ENDIAN
#define SERIAL_REP SERIAL_@SERIAL_REP@_REP


CPP_EXTERNC_BEGIN
// strict aliasing:
// signed* to unsigned* and dereferencing result is allowed
// However, typecasting signed to unsigned may be undefined
// as a result, because data is stored into unsigned char*
// all signed store/load will typealias and call unsigned
// versions
//
// Just a side note, maybe fix it if I ever encounter an issue but...
// 0xFF as bitmask assumes 2's complement right? What if
// not 2's complement? Does that mean I have to explicitly
// calculate all the bits in a 2's complement representation?
// (Divide by 2, mod 1?, store the bit via shifts if applicable?)
// The code here actually only addresses the endianness issue.

//unsigned only depends on endianness


#define SERIAL_OPT (CHAR_BIT==8 && SERIAL_ENDIAN!=SERIAL_UNKNOWN_ENDIAN)

#if defined(UINT16_MAX) && SERIAL_OPT

#if SERIAL_ENDIAN == SERIAL_BIG_ENDIAN
inline void serial__store_ui16(unsigned char *data, uint_least16_t value)
{ memcpy(data, &value, sizeof(value)); }
inline uint_least16_t serial__load_ui16(const unsigned char *data)
{
	uint_least16_t value;
	memcpy(&value, data, sizeof(value));
	return value;
}
#else
inline void serial__store_ui16(unsigned char *data, uint_least16_t value)
{
	const unsigned char *src = (unsigned char *) &value;
	data[0] = src[1];
	data[1] = src[0];
}
inline uint_least16_t serial__load_ui16(const unsigned char *data)
{
	uint_least16_t value;
	unsigned char *dst = (unsigned char *) &value;
	dst[0] = data[1];
	dst[1] = data[0];
	return value;
}
#endif

#else
inline void serial__store_ui16(unsigned char *data, uint_least16_t value)
{
	data[0] = (value >> 8) & 0xFFu;
	data[1] = value & 0xFFu;
}
inline uint_least16_t serial__load_ui16(const unsigned char *data)
{
	return (uint_least16_t) data[0] << 8 | data[1];
}
#endif


#if defined(UINT32_MAX) && SERIAL_OPT

#if SERIAL_ENDIAN == SERIAL_BIG_ENDIAN
inline void serial__store_ui32(unsigned char *data, uint_least32_t value)
{ memcpy(data, &value, sizeof(value)); }
inline uint_least32_t serial__load_ui32(const unsigned char *data)
{
	uint_least32_t value;
	memcpy(&value, data, sizeof(value));
	return value;
}
#else
inline void serial__store_ui32(unsigned char *data, uint_least32_t value)
{
	const unsigned char *src = (unsigned char *) &value;
	data[0] = src[3];
	data[1] = src[2];
	data[2] = src[1];
	data[3] = src[0];
}
inline uint_least32_t serial__load_ui32(const unsigned char *data)
{
	uint_least32_t value;
	unsigned char *dst = (unsigned char *) &value;
	dst[0] = data[3];
	dst[1] = data[2];
	dst[2] = data[1];
	dst[3] = data[0];
	return value;
}
#endif

#else
inline void serial__store_ui32(unsigned char *data, uint_least32_t value)
{
	data[0] = (value >> 24) & 0xFFu;
	data[1] = (value >> 16) & 0xFFu;
	data[2] = (value >> 8) & 0xFFu;
	data[3] = value & 0xFFu;
}
inline uint_least32_t serial__load_ui32(const unsigned char *data)
{
	return (
		(uint_least32_t) data[0] << 24 | (uint_least32_t) data[1] << 16
		| (uint_least32_t) data[2] << 8 | data[3]);
}
#endif


#if defined(UINT64_MAX) && SERIAL_OPT

#if SERIAL_ENDIAN == SERIAL_BIG_ENDIAN
inline void serial__store_ui64(unsigned char *data, uint_least64_t value)
{ memcpy(data, &value, sizeof(value)); }
inline uint_least64_t serial__load_ui64(const unsigned char *data)
{
	uint_least64_t value;
	memcpy(&value, data, sizeof(value));
	return value;
}
#else
inline void serial__store_ui64(unsigned char *data, uint_least64_t value)
{
	const unsigned char *src = (unsigned char*) &value;
	data[0] = src[7];
	data[1] = src[6];
	data[2] = src[5];
	data[3] = src[4];
	data[4] = src[3];
	data[5] = src[2];
	data[6] = src[1];
	data[7] = src[0];
}
inline uint_least64_t serial__load_ui64(const unsigned char *data)
{
	uint_least64_t value;
	unsigned char *dst = (unsigned char*) &value;
	dst[0] = data[7];
	dst[1] = data[6];
	dst[2] = data[5];
	dst[3] = data[4];
	dst[4] = data[3];
	dst[5] = data[2];
	dst[6] = data[1];
	dst[7] = data[0];
	return value;
}
#endif

#else
inline void serial__store_ui64(unsigned char *data, uint_least64_t value)
{
	data[0] = (value >> 56) & 0xFFu;
	data[1] = (value >> 48) & 0xFFu;
	data[2] = (value >> 40) & 0xFFu;
	data[3] = (value >> 32) & 0xFFu;
	data[4] = (value >> 24) & 0xFFu;
	data[5] = (value >> 16) & 0xFFu;
	data[6] = (value >> 8) & 0xFFu;
	data[7] = value & 0xFFu;
}

inline uint_least64_t serial__load_ui64(const unsigned char *data)
{
	return (
		(uint_least64_t) data[0] << 56
		| (uint_least64_t) data[1] << 48
		| (uint_least64_t) data[2] << 40
		| (uint_least64_t) data[3] << 32
		| (uint_least64_t) data[4] << 24
		| (uint_least64_t) data[5] << 16
		| (uint_least64_t) data[6] << 8
		| data[7]);
}
#endif

#if SERIAL_REP == SERIAL_TWO_REP
//already two's complement

inline void serial__store_i16(unsigned char *data, int_least16_t value)
{ serial__store_ui16(data, *((uint_least16_t*) &value)); }
inline void serial__store_i32(unsigned char *data, int_least32_t value)
{ serial__store_ui32(data, *((uint_least32_t*) &value)); }
inline void serial__store_i64(unsigned char *data, int_least64_t value)
{ serial__store_ui64(data, *((uint_least64_t*) &value)); }
inline int_least16_t serial__load_i16(const unsigned char *data)
{
	uint_least16_t v = serial__load_ui16(data);
	return *((int_least16_t*) &v);
}
inline int_least32_t serial__load_i32(const unsigned char *data)
{
	uint_least32_t v = serial__load_ui32(data);
	return *((int_least32_t*) &v);
}
inline int_least64_t serial__load_i64(const unsigned char *data)
{
	uint_least64_t v = serial__load_ui64(data);
	return *((int_least64_t*) &v);
}

#else
//positive = same as twos complement
inline void serial__store_i16(unsigned char *data, int_least16_t value)
{
	if (value > 0)
	{ serial__store_ui16(data, *((uint_least16_t*) &value)); }
	else
	{ serial__store_ui16(data, ~(uint_least16_t)(-1 - value)); }
}
inline void serial__store_i32(unsigned char *data, int_least32_t value)
{
	if (value > 0)
	{ serial__store_ui32(data, *((uint_least32_t*) &value)); }
	else
	{ serial__store_ui32(data, ~(uint_least32_t)(-1 - value)); }
}
inline void serial__store_i64(unsigned char *data, int_least64_t value)
{
	if (value > 0)
	{ serial__store_ui64(data, *((uint_least64_t*) &value)); }
	else
	{ serial__store_ui64(data, ~(uint_least64_t)(-1 - value)); }
}

inline int_least16_t serial__load_i16(const unsigned char *data)
{
	uint_least16_t v = serial__load_ui16(data);
	if (v >> 15)
	{ return -1 - (int_least16_t) ~v; }
	return v;
}
inline int_least32_t serial__load_i32(const unsigned char *data)
{
	uint_least32_t v = serial__load_ui32(data);
	if (v >> 31)
	{ return -1 - (int_least32_t) ~v; }
	return v;
}
inline int_least64_t serial__load_i64(const unsigned char *data)
{
	uint_least64_t v = serial__load_ui64(data);
	if (v >> 63)
	{ return -1 - (int_least64_t) ~v; }
	return v;
}
#endif
CPP_EXTERNC_END
