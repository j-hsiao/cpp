#define AES_DEBUG 1
#include "aes/keys.hpp"
#include "aes/hexlog.hpp"
#include "aes/plain.hpp"
#include "aes/uil32.hpp"
#include "aes/ui32.hpp"
#include "aes/raw.hpp"

#include <cstring>
#include <iostream>

void print_keys(unsigned char *buf, const aes::Version &version)
{
	auto end = buf + aes::State_Bytes*version.Round_Keys;
	std::cerr << "------------------------------" << std::endl;
	for (auto start = buf; start < end; start += aes::State_Bytes)
	{ std::cerr << aes::hex(start, aes::State_Bytes) << std::endl; }
}

const std::string key128("Thats my Kung Fu", aes::aes128.Key_Bytes);
const std::string expanded128(
	"\x54\x68\x61\x74\x73\x20\x6d\x79\x20\x4b\x75\x6e\x67\x20\x46\x75"
	"\xe2\x32\xfc\xf1\x91\x12\x91\x88\xb1\x59\xe4\xe6\xd6\x79\xa2\x93"
	"\x56\x08\x20\x07\xc7\x1a\xb1\x8f\x76\x43\x55\x69\xa0\x3a\xf7\xfa"
	"\xd2\x60\x0d\xe7\x15\x7a\xbc\x68\x63\x39\xe9\x01\xc3\x03\x1e\xfb"
	"\xa1\x12\x02\xc9\xb4\x68\xbe\xa1\xd7\x51\x57\xa0\x14\x52\x49\x5b"
	"\xb1\x29\x3b\x33\x05\x41\x85\x92\xd2\x10\xd2\x32\xc6\x42\x9b\x69"
	"\xbd\x3d\xc2\x87\xb8\x7c\x47\x15\x6a\x6c\x95\x27\xac\x2e\x0e\x4e"
	"\xcc\x96\xed\x16\x74\xea\xaa\x03\x1e\x86\x3f\x24\xb2\xa8\x31\x6a"
	"\x8e\x51\xef\x21\xfa\xbb\x45\x22\xe4\x3d\x7a\x06\x56\x95\x4b\x6c"
	"\xbf\xe2\xbf\x90\x45\x59\xfa\xb2\xa1\x64\x80\xb4\xf7\xf1\xcb\xd8"
	"\x28\xfd\xde\xf8\x6d\xa4\x24\x4a\xcc\xc0\xa4\xfe\x3b\x31\x6f\x26",
	aes::aes128.Round_Keys * aes::State_Bytes);
const std::string decryptkeys128(
	"\x28\xfd\xde\xf8\x6d\xa4\x24\x4a\xcc\xc0\xa4\xfe\x3b\x31\x6f\x26"
	"\xca\x44\x2e\xd2\x75\x47\x62\x04\x8c\xe2\x54\xcb\xb6\x9c\xa0\x9f"
	"\x2d\x74\x6e\x26\xbf\x03\x4c\xd6\xf9\xa5\x36\xcf\x3a\x7e\xf4\x54"
	"\x22\x88\x5a\x51\x92\x77\x22\xf0\x46\xa6\x7a\x19\xc3\xdb\xc2\x9b"
	"\xf6\xb1\x18\x9a\xb0\xff\x78\xa1\xd4\xd1\x58\xe9\x85\x7d\xb8\x82"
	"\xf8\x19\x49\x38\x46\x4e\x60\x3b\x64\x2e\x20\x48\x51\xac\xe0\x6b"
	"\xf3\xe6\xa0\xcd\xbe\x57\x29\x03\x22\x60\x40\x73\x35\x82\xc0\x23"
	"\x52\x3e\x3d\x09\x4d\xb1\x89\xce\x9c\x37\x69\x70\x17\xe2\x80\x50"
	"\xb5\xf8\x31\x05\x1f\x8f\xb4\xc7\xd1\x86\xe0\xbe\x8b\xd5\xe9\x20"
	"\x4e\xfb\xf1\x99\xaa\x77\x85\xc2\xce\x09\x54\x79\x5a\x53\x09\x9e"
	"\x54\x68\x61\x74\x73\x20\x6d\x79\x20\x4b\x75\x6e\x67\x20\x46\x75",
	aes::aes128.Round_Keys * aes::State_Bytes);

const std::string key256(
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01",
	aes::aes256.Key_Bytes);
const std::string expanded256(
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01"
	"\x62\x63\x7c\x63\x62\x63\x7c\x63\x62\x63\x7c\x63\x62\x63\x7c\x63"
	"\xaa\xfb\x10\xfb\xaa\xfb\x10\xfb\xaa\xfb\x10\xfb\xaa\xfb\x10\xfa"
	"\x6f\xa9\x51\xcf\x0d\xca\x2d\xac\x6f\xa9\x51\xcf\x0d\xca\x2d\xac"
	"\x7d\x8f\xc8\x6a\xd7\x74\xd8\x91\x7d\x8f\xc8\x6a\xd7\x74\xd8\x90"
	"\xf9\xc8\x31\xc1\xf4\x02\x1c\x6d\x9b\xab\x4d\xa2\x96\x61\x60\x0e"
	"\xed\x60\x18\xc1\x3a\x14\xc0\x50\x47\x9b\x08\x3a\x90\xef\xd0\xaa"
	"\x2e\xb8\x9d\xa1\xda\xba\x81\xcc\x41\x11\xcc\x6e\xd7\x70\xac\x60"
	"\xe3\x31\x89\x11\xd9\x25\x49\x41\x9e\xbe\x41\x7b\x0e\x51\x91\xd1"
	"\xef\x39\xa3\x0a\x35\x83\x22\xc6\x74\x92\xee\xa8\xa3\xe2\x42\xc8"
	"\xe9\xa9\xa5\xf9\x30\x8c\xec\xb8\xae\x32\xad\xc3\xa0\x63\x3c\x12"
	"\x34\xd2\x6a\xea\x01\x51\x48\x2c\x75\xc3\xa6\x84\xd6\x21\xe4\x4c"
	"\x1f\x54\xcc\xd0\x2f\xd8\x20\x68\x81\xea\x8d\xab\x21\x89\xb1\xb9"
	"\xd3\x1a\x3c\x17\xd2\x4b\x74\x3b\xa7\x88\xd2\xbf\x71\xa9\x36\xf3",
	aes::aes256.Round_Keys * aes::State_Bytes);
const std::string decryptkeys256(
	"\xd3\x1a\x3c\x17\xd2\x4b\x74\x3b\xa7\x88\xd2\xbf\x71\xa9\x36\xf3"
	"\x31\x80\x4c\xaa\xd6\xf5\xbc\x20\x74\x28\xe2\xf3\xcb\xee\x00\x85"
	"\xfb\x22\x69\xd6\x11\x03\x30\x16\x3b\x56\xdb\x22\x7a\x8e\xf6\x5d"
	"\xbe\x16\xca\x7e\xe7\x75\xf0\x8a\xa2\xdd\x5e\xd3\xbf\xc6\xe2\x76"
	"\xd9\x70\x6b\xbd\xea\x21\x59\xc0\x2a\x55\xeb\x34\x41\xd8\x2d\x7f"
	"\xc3\xf6\x3d\x42\x59\x63\x3a\xf4\x45\xa8\xae\x59\x1d\x1b\xbc\xa5"
	"\x6e\x1b\x92\x4d\x33\x51\x32\x7d\xc0\x74\xb2\xf4\x6b\x8d\xc6\x4b"
	"\xd7\xe0\x8a\xe9\x9a\x95\x07\xb6\x1c\xcb\x94\xad\x58\xb3\x12\xfc"
	"\x05\x96\x54\x06\x5d\x4a\xa0\x30\xf3\x25\x80\x89\xab\xf9\x74\xbf"
	"\x86\x5e\x93\x1b\x4d\x75\x8d\x5f\x86\x5e\x93\x1b\x44\x78\x86\x51"
	"\xae\x6f\x20\xb9\x58\xdc\xf4\x36\xae\x6f\x20\xb9\x58\xdc\xf4\x36"
	"\xcb\x2b\x1e\x44\xcb\x2b\x1e\x44\xcb\x2b\x1e\x44\xc2\x26\x15\x4a"
	"\xf6\xb3\xd4\x8f\xf6\xb3\xd4\x8f\xf6\xb3\xd4\x8f\xf6\xb3\xd4\x8f"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x09\x0d\x0b\x0e"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
	aes::aes256.Round_Keys * aes::State_Bytes);

template<class Keys>
int check()
{
	std::string buf(expanded128.size(), 0);
	Keys keys128(key128.c_str(), aes::aes128);
	keys128.store(&buf[0]);
	if (buf != expanded128)
	{
		std::cerr << "expand 128 failed" << std::endl
			<< "result:\n" << aes::hex(buf) << std::endl
			<< "expected:\n" << aes::hex(expanded128) << std::endl;
		return 1;
	}
	Keys dkeys128(keys128.reverse());
	dkeys128.store(&buf[0]);
	if (buf != decryptkeys128)
	{
		std::cerr << "decrypt 128 failed" << std::endl
			<< "result:\n" << aes::hex(buf) << std::endl
			<< "expected:\n" << aes::hex(decryptkeys128) << std::endl;
		return 1;
	}

	buf.resize(expanded256.size(), 0);
	Keys keys256(key256.c_str(), aes::aes256);
	keys256.store(&buf[0]);
	if (buf != expanded256)
	{
		std::cerr << "expand 256 failed" << std::endl
			<< "result:\n" << aes::hex(buf) << std::endl
			<< "expected:\n" << aes::hex(expanded256) << std::endl;
		return 1;
	}
	Keys dkeys256 = keys256.reverse();
	dkeys256.store(&buf[0]);
	if (buf != decryptkeys256)
	{
		std::cerr << "decrypt 256 failed" << std::endl
			<< "result:\n" << aes::hex(buf) << std::endl
			<< "expected:\n" << aes::hex(decryptkeys256) << std::endl;
		return 1;
	}
	std::cerr << "passed" << std::endl;
	return 0;
}

template<class T>
int checkraw()
{
	std::string buf(expanded128.size(), 0);
	T k128(key128.c_str(), aes::aes128);
	k128.storekey(&buf[0], k128.ekey);
	if (buf != expanded128)
	{
		std::cerr << "raw 128 init keys failed" << std::endl;
		std::cerr << "result " << aes::hex(buf) << std::endl;
		std::cerr << "expect " << aes::hex(expanded128) << std::endl;
		return 1;
	}
	k128.storekey(&buf[0], k128.dkey);
	if (buf != decryptkeys128)
	{
		std::cerr << "raw 128 decrypt keys failed" << std::endl;
		return 1;
	}

	buf.resize(expanded256.size(), 0);
	T k256(key256.c_str(), aes::aes256);
	k256.storekey(&buf[0], k256.ekey);
	if (buf != expanded256)
	{
		std::cerr << "raw 256 init keys failed" << std::endl;
		return 1;
	}
	k256.storekey(&buf[0], k256.dkey);
	if (buf != decryptkeys256)
	{
		std::cerr << "raw 256 decrypt keys failed" << std::endl;
		return 1;
	}
	std::cerr << "passed" << std::endl;
	return 0;
}

int main(int argc, char *argv[])
{
#if defined(_WIN32) && TESTING_DLL
	return 0;
#else
	return (
		0
		|| (std::cerr << "uileast 32 keys" << std::endl,
			check<aes::uil32::Keys>())

#		if AES_USE_UI32
		|| (std::cerr << "ui32 keys" << std::endl,
			check<aes::ui32::Keys>())
#		endif

#		if defined(AES_USE_PLAIN) && AES_USE_PLAIN
		|| (std::cerr << "plain keys" << std::endl,
			check<aes::plain::Keys>())
#		endif

		|| (std::cerr << "raw uil32" << std::endl,
			checkraw<aes::Impl_RawUIL32>())
		|| (std::cerr << "raw ui32" << std::endl,
			checkraw<aes::Impl_RawUI32>())
	);
#endif
}
